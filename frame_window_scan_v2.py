import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from core import *
import os


# -- Upload de Arquivos --
st.sidebar.header("üìÇ Upload Files")
uploaded_files = st.sidebar.file_uploader(
    "Upload your fingerprint CSV files",
    type="csv",
    accept_multiple_files=True
)
st.sidebar.info("The datasets should be CSV files generated by ProLIF containing molecular interaction fingerprints.")

# -- Armazena os arquivos em mem√≥ria na sess√£o --
if uploaded_files:
    if "uploaded_csvs" not in st.session_state:
        st.session_state.uploaded_csvs = {}
    for file in uploaded_files:
        st.session_state.uploaded_csvs[file.name] = file

# -- Sele√ß√£o de Arquivos --
if "uploaded_csvs" in st.session_state and len(st.session_state.uploaded_csvs) >= 2:
    file_names = list(st.session_state.uploaded_csvs.keys())
    file1_name = st.sidebar.selectbox("File 1", file_names, index=0)
    file2_name = st.sidebar.selectbox("File 2", file_names, index=1)

    WIN = st.sidebar.slider("Frame Window Size", min_value=10, max_value=200, value=50, step=1)

    file1 = st.session_state.uploaded_csvs[file1_name]
    file2 = st.session_state.uploaded_csvs[file2_name]

    # -- Leitura e limpeza dos dados --
    df1_raw = pd.read_csv(file1, header=None)
    df2_raw = pd.read_csv(file2, header=None)

    df1 = load_and_clean_fingerprint(df1_raw)
    df2 = load_and_clean_fingerprint(df2_raw)

    if df1 is not None and df2 is not None:
        common_cols = df1.columns.intersection(df2.columns)
        if common_cols.empty:
            st.error("No matching fingerprint columns found.")
        else:
            df1 = df1[common_cols]
            df2 = df2[common_cols]
            frames = sorted(set(df1.index) & set(df2.index))
            N = len(frames)

            if N < WIN:
                st.warning(f"Need at least {WIN} frames, found {N}.")
            else:
                f1_all = df1.loc[frames].to_numpy()
                f2_all = df2.loc[frames].to_numpy()

                st.info("üìä Precomputing full similarity matrix...")
                full_sim = np.zeros((N, N))
                progress = st.progress(0, text="Computing similarities...")
                for i in range(N):
                    for j in range(N):
                        full_sim[i, j] = tanimoto_similarity(f1_all[i], f2_all[j])
                    progress.progress((i + 1) / N, text=f"Similarity matrix: {int((i + 1) / N * 100)}%")
                progress.empty()

                # -- Varredura de janelas --
                st.info("üîç Scanning all window combinations...")
                max_avg = -1
                best_i = best_j = -1
                total = (N - WIN + 1) ** 2
                counter = 0
                progress = st.progress(0, text="Scanning windows...")

                for i in range(N - WIN + 1):
                    for j in range(N - WIN + 1):
                        window = full_sim[i:i + WIN, j:j + WIN]
                        avg = window.mean()
                        if avg > max_avg:
                            max_avg = avg
                            best_i, best_j = i, j
                        counter += 1
                        if counter % 500 == 0 or counter == total:
                            progress.progress(counter / total, text=f"Window scan: {int(counter / total * 100)}%")
                progress.empty()

                # -- Resultado √≥timo --
                best_frame_A = frames[best_i]
                best_end_A = frames[best_i + WIN - 1]
                best_frame_B = frames[best_j]
                best_end_B = frames[best_j + WIN - 1]
                best_window = full_sim[best_i:best_i + WIN, best_j:best_j + WIN]

                st.header("üèÜ Optimal Similarity Window Found")
                col1, col2 = st.columns(2)
                with col1:
                    st.metric("Max. Avg. Tanimoto Similarity", f"{max_avg:.4f}")
                with col2:
                    st.metric("Optimal A vs B Frame Windows", f"A: {best_frame_A}-{best_end_A} | B: {best_frame_B}-{best_end_B}")

                # -- Mapa completo com janela √≥tima destacada --
                fig1, ax1 = plt.subplots(figsize=(9, 9))
                im = ax1.imshow(full_sim, cmap="cubehelix_r", vmin=0, vmax=1)
                ax1.invert_yaxis()
                plt.colorbar(im, ax=ax1).set_label("Similarity")
                rect = patches.Rectangle((best_j, best_i), WIN, WIN, linewidth=2, edgecolor='red', facecolor='none')
                ax1.add_patch(rect)
                ax1.set_title("All Frame Similarities with Optimal Window Highlighted")
                ax1.set_xlabel("File 2 ‚Äì Frame n¬∫ (B)")
                ax1.set_ylabel("File 1 ‚Äì Frame n¬∫ (A)")
                st.pyplot(fig1)

                # -- Mapa de calor da melhor janela --
                fig2, ax2 = plt.subplots(figsize=(8, 6))
                sns.heatmap(best_window,
                            cmap="cubehelix_r", vmin=0, vmax=1, ax=ax2,
                            xticklabels=frames[best_j:best_j + WIN],
                            yticklabels=frames[best_i:best_i + WIN])
                ax2.invert_yaxis()
                ax2.set_title(f"Tanimoto Similarity (Optimal Window)\nA: {best_frame_A}-{best_end_A} vs B: {best_frame_B}-{best_end_B}")
                ax2.set_xlabel("B ‚Äì Frame Number")
                ax2.set_ylabel("A ‚Äì Frame Number")
                st.pyplot(fig2)

else:
    st.warning("Please upload **at least two** fingerprint CSV files.")